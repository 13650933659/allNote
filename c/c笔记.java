

学习顺序
	c -> 数据结构 -> uc -cpp

1、郝斌的
	1、零基础学习C语言的基本语法可以看郝斌的视频，通俗易懂，听起来也不枯燥，比较轻松。现在我正在看 “香蕉地”老张的视频，推荐给有点语法基础的同学，懂点C就能写软件写游戏，我已经变身成迷弟了。这两位老师的视频一定是良心之作，初学C的不能放过。




	1、unix/linux/C的历史
		1、 CPL -> BCPL -> 1969用汇编写操作系统 -> 1971年B(Ken.Thompson写的，当时他还用B写了unix) 
		-> 1972年C(Dennis.M.Ritchie 和 Ken.Thompson 一起结合B升级的，后来他俩合作用C改写了unix，慢慢的B就淘汰了)
		-> 由于unix收费的而且庞大，所以有linux，linux系统是一款自由免费开放源代码的类Unix操作系统,早期linux只是用于表示系统的内核,
		后来大家都习惯于将以linux作为内核的操作系统都统称为linux系统，
		三大问题的解决，使得linux的应用广泛
			界面(GNU) 兼容性(POSIX 定义和unix的通用接口) 版权(GPL通用公共许可证)
		2、 C -> C++ -> java 、 C# 这个两个语言结合 C++ 诞生了 java 、 C#他俩语法很类似
	2、C语言的发展过程
		1、1983年 ANSI C
		2、1987年 ANSI C 87(好像是C89)
		3、1994年 C99






1、第一天简单介绍 linux
2、第二天 简单介绍C程序的结构
	1、C原文件是以.c或者.h结尾
	2、主函数应该有一个返回值，0正常结束 其他数字表示异常，但是这个返回值我们不怎么用
	3、预处理语句(在编译时执行的代码，不可以用分号结尾)
		1、#include "a.h" 如果使用<>包着表示采用系统中预先准备好的目录作为起点
		2、宏
			1、 #define	PI 3.14f			// 这个也叫宏定义，他比较快，他在程序内存不存在的，区别变量，可能在其他地方存着，他在里面没运算的，而是嵌入你引用的地方，然后再去运算
			2、 #define	CIRCLE(r) 2*PI*r	// 宏也是可以传参数给他的，他参数类型不确定的，也可以是表达式但是你也需要加入()，保证优先级，也可以多个，里面也可以使用三木运算符，里面对参数的操作会保留的，(2*PI*r)宏里面的计算最好加上括号这样才能保证优先级
			2、 # 操作符					// 只能在宏的参数上使用，把参数的字面值变成字符串
			3、 ## 连接符					// 只能在宏的参数上使用，例如 #define	CIRCLE(r) g_##r		这个用于动态变量名称
			4、c语言预定义好的宏
				__BASE_FILE__   - 获取正在编译的文件名  %s
				__FILE__        - 获取当前宏所在的文件名 %s
				__LINE__        - 获取当前宏所在的行号   %d
				__FUNCTION__    - 获取当前宏所在的函数名 %s
				__DATE__        - 获取日期     %s
				__TIME__        - 获取时间     %s
		3、预处理语句的应用(条件编译)
			1、if\else
				#ifdef ONE	// 如果有定义ONE宏就成立，#ifdef 则相反
					printf("1");
				#else
					printf("2");
				#endif
			2、 if\else if\else
				#if defined(ONE)
				#elif defined(TOW)
				#else
				#endif
		4、全部预处理指令
			#include - 主要用于包含头文件
			#define  - 进行宏定义
			#undef   - 取消宏定义 
			#if      - 如果 ...
			#ifdef   - 如果定义 ...
			#ifndef  - 如果没有定义 ...
			#elif    - 否则如果 ...
			#else    - 否则 ...
			#endif   - 结束如果

			#warning - 输出警告
			#error   - 输出错误，并中断编译
			#pragma  - 提供额外的标准方法，可用来指定平台
			##	    - 连接操作符号，用于连接宏内两个字符串
			#pragma
				#pragma GCC dependency a.txt
					=> a.txt文件最后一次修改时间晚于当前文件，则产生警告信息，如果是团队开发，而且依赖文件 a.txt很重要，不能被随便修改
				#pragma GCC poison 标识符(比如 goto)  
					=> 设置指定的标识符为毒药,一旦使用该标识符，则产生错误信息
				#pragma pack(n)
				  => 表示按照n的倍数进行对齐和补齐,超过4按照4的倍数进行，并且对齐和补齐的形式必须是2的较小次方，为了节省内存空间
			#line 整数n - 表示从下一行开始行号变更为第n行
	
	4、注释(//和/**/)
	5、命名规则：第一个字符应该是英文字母或者下划线，大小写敏感
	6、编译器可以把源文件翻译成计算机能认识的格式(中间还有一个过渡汇编)
		gcc是Linux系统里C语言程序的编译器
		MinGW是Windows下的gcc
	
	8、转意字符
		'\n'    换行(到下一行，但不一定是行首)
		'\r'    回车(回到本行行首，不结合\n使用，就会覆盖开头的字符)
		'\r\n'	回车换行(一般这样来使用吧，可能linux的\n就相当于\r\n了)
		'\t'    代表制表符
	12、数据类型和占位符的对应关系
		1、 ascii (ascii 码用来表示 char 类型的，由于现在的字符越来越多所以iso-8859、gbk、utf-8等编码，但是这些编码都是兼容ascii)
			1、 ascii 码一共有256个，分为两组，0-127是明确表示的字符，另外一组(-1到-128 或者 128 到 256 表示的字符不确定的 )
			2、 unsigned char(无符号数据类型)，即对应ascii码是非负数的
		2、数据类型：任何数据类型所能表示的数字个数由这个类型所占的位数决定（比如：char占1Byte=8bit=2^8=256个数字）
			1、char					  %c[1个字节]
			2、unsigned char 			  %c[1个字节]
			4、short                     %hd(65536个整数 -32768 到 32767)[2个字节]
			5、unsigned short            %hu(65536个整数 0 到 65535)[2个字节]
			6、int                       %d(在我们使用的计算机和编译器中int和long是一样的)[4个字节]
			7、unsigned int              %u[4个字节]
			8、long                      %ld(2^64个整数 -2^63 到 2^63-1)[8个字节]
			9、unsigned long             %lu(2^64个整数 0 到 2^64-1)[8个字节]
			10、float                     %f 或 %g(精确到6位小数)[4个字节]
			11、double                    %lf 或 %lg(精确到16位小数)[8个字节]
			12、八进制				      %o
			13、十六进制				  %x 或 %X
			14、bool					  // 要用这个类型需要引入 #include <stdbool.h>-C99
			15、数组	// 他是常指针，即不可以改变地址，但是可以改变里面的元素值
				1、数组的初始化
					int arr[3] = {1,2,3};	// 常用
					int arr[] = {1,2,3};	// 和第一种一样的效果
					int arr[3] = {};		// 长度还是3占的空间还是3
					int arr[3];				// 长度还是3占的空间还是3
				2、数组的大小： sizeof(arr) / sizeof(arr[0]) = 数组占的大小/每个元素的大小
				3、数组运算
					1、arr		// 下标为0的元素在内存的位置，相当于 &arr[0]，也可以看出数组的位置
					2、arr + 2	// 下标为2的元素在内存的位置，2代表2个元素所占的空间
					3、*(arr+n)	// 下标为n的元素的值
				4、 int arr[v]			// 这是不定数组，但是他不能初始化
				5、二维数组和多维数组
					1、声明： 
						int arr[2][3] = {{1,2,3},{4,5,6}};
						int arr[2][3] = {1,2,3,4,5,6};
						int arr[][3] = {{1,2,3},{4,5,6}};
			16、指针：是用来存储其他变量地址的，但是他本身也是在内存存在的，前提知识：内存就是很多个格子，一格=1字节，一个变量占连续的多格，最前面那个是他的地址，使用long来表示这个地址，也是指针的值	// %p(以十六进制的打印)
				1、普通的指针
					1、指针变量的赋值
						 int* p_num = NULL;
						 p_num = &num;
						*p_num 就等于 num， 但是 p_num 他是指针变量，他也是有自己的值的，他的值是指向普通变量的地址
					2、所有指针类型和int\long可以任意转换
						int* p_num = &num;
						int i = (int)p_num	// 强成int
						p_num = (int*) i;	// 强转成指针类型
					3、指针可以做参数，但是函数中对指针的本身修改不会保留，但是对指针对应的普通变量的修改会保留
						void neg(int* p_num, int size){	// 预声明 void neg(int *, int);
							int i = 0;
							for (i = 0; i < size; i++){
								p_num[i] = 0 - p_num[i];
							}
						}
						int arr[] = {1,2,3};
						neg(arr, 3);		// 这是调用形参为指针的函数，传的是地址
					4、指针也可以做返回值
						int* min(int* p, int size) {}
					5、指针和指针不可以做加运算，但是减是可以的 p_num1 - p_num2(√)，指针和整数可以做加减运算，p_unm1 + 2(√)，2是2个数据类型，比如是int那就是 2*4字节(格子)
					6、数组和指针的区别(大多情况下使用起来是一样的)
						1、数据名称初始化之后不可以别赋值的 arr = null;(×)，因为数据名称是临时算出来的
						2、进行sizeof()计算不同，数组是大数组的大小，指针是他指针的大小8字节
						3、进行&取地址不同，&arr(他会变成一个二维数据组里面只有原来的数据组一个元素，但是地址值还是等于之前数组的地址值，一般我们取数组的地址直接arr即可)，&p_a是p_a本身的地址
				2、二级指针，使用来记录一级指针变量的地址
					1、最好使用 int **pp_ 开头
						int *p_v = &v;
						int **pp_v = &p_v;
					2、指针数组的变量可以直接赋值给二级指针，但是二维数组不可以
					3、可以使用他来关闭指针(二级指针做参数)
						void destroy(int **pp_v) {
							free(*pp_v);
							*pp_v = NULL;
						}
						destory(&p_v);
				3、void指针：没声明地址，使用前必须强转成其他指针
					1、声明： void p_num = &num;
					2、使用： *(int*)p_num = 3;		// 虽然你给的地址很明确，但是你用时必须强转
				4、函数指针
					1、例子
						int add(int x, int y){return x +y;}		// 函数名称就是他地址
						int (*p_func)(int, int) = NULL;
						p_func = add;
						p_func(1,2);		// 这是通过指针调用
					2、函数指针做参数
						void sort(int *p_arr, int size, int (*comp)(int, int)){}
			17、字符串(%s)：由多个连续的字符构成的，用第一个字符变量的地址来表示整个字符串的地址，通常使用指针(char* p_s)或者字符数组(char p_s[])来表示他，所有字符串的结尾是'\0'(ascii码是0，就是空字符)结尾
				1、字符串不可以被修改，但是字符串数组可以被修改，同样的字面值在内存中只有一份，但是字符数组就不是了
				2、字符数组也可以用来表示字符串，  但是区别于真正的字符串后面是否有'\0'结尾， 如果 你是char arr[] = "abc";可以当字符串用, char arr[] = {'a','b'}这个不能当字符串用
				3、c提供了对字符串基本操作的函数<string.h>
					1、 strlen(s)			// 计算字符串的有效长度('\0'除外)
					2、 strcat(s1,s2)		// 把第二个字符串，合并到第一个字符串数组，这个有风险，合并之后可能超过数组范围
					3、 strncat				// 类似strcat功能，但是不会超过数组范围
					4、 strcmp(s1,s2)		// 比较两个字符串的大小(比较的依据是ascii码)，返回结果1 s1>s2,-1s1<s2,0s1=s2
					5、 strncmp(s1,s2,len)		// 和strcmp类似，但是他只比较前n个字符
					6、 strcpy(s1,s2)				// s2拷贝到s1，拷贝之后在内存中有两个完全一样的字符串
					7、 strncpy(s1,s2)				// 和strcpy类似，拷贝前n个字符
				4、使用scanf("%s", arr)读取字符串到数组中有风险
					1、遇到空格，空格前面的读取，后面的不要了
					2、如果超过了数组的长度，会把内存中其他值改了
					3、使用fgets(arr, 10, stdin)	// 读九个字符，解决了上面两个问题，但是最后回车(\n)也会被读到
						1、最好加入如下清空代码，要不然剩余的字符会影响下面的接收
							if(strlen(arr) == 9 && arr[8] != '\n'){
									printf("清空输入缓存区\n");
									scanf("%*[^\n]");
									scanf("%*c");
							}
				5、多个字符串的表示
					1、二维数组 char[5][3]		// 容易造成浪费
					2、指针数组 char* str[5]=char** p_str(二级指针)	// *(str + 3)=str[3] 这个是指针，**(str + 3)这个才是普通变量
			18、结构体
				1、声明(最好放在头文件，这样很多地方都可以用了，而且结果体里面不可以声明函数，但c++可以)
					struct person {
						int id;
						char name[20];
						float salary;
						// 函数指针可以作为结构体的变量
					}

					我们还可以直接声明结果体变量，但是这样只能声明p，其他变量就不能以他为模板了
						struct {
							int id;
							char name[20];
							float salary;
						} p;
				2、使用
					1、正常使用
						struct person p = {1, "zs", 10.0};
						p.id = 1;
						strcpy(p.name, "abc");	// 需要使用 <string.h>
					2、结构体的数组使用
						struct month months[2] = {{"Jan", 31},{"Feb", 28}};
					3、 typedef 关键字
						1、typedef struct month month;	// 把struct month 取别名 month，也可以在结构体后面加别名，在这里加了，结构体的名称可以省略，但开头也要用typedef，也可以使用宏，但是在给指针取别名就有区别了
					4、结构体做参数，最好用结构体的指针，要不然方法内会复制这个结构体，很慢
						1、 &p1，传结构体的地址，但是函数使用时使用： p_person -> name
					5、如果结构体做返回值，如果你返回的是方法里面的结构体的地址，但是不可靠的，如果你直接返回这个结构体，他有复制的操作，很慢，所以你想用结构体做返回值，最好使用结构体的指针做为参数吧
					6、数据对齐
						1、变量的地址一定是他大小的整数倍，在32位计算机double是4的整数倍，所以他是在内存排列有空隙的不像数组，所以结构体里边的变量顺序最好从小到大，这样空隙就小
					7、数据补齐	// 占地最大的变量的整数倍，但是double看成4，不够后面使用空字符补齐
			19、联合
				1、声明
					union u1 {	// 也可以使用typedef起别名
						int v;
						char ch[4];
					};
				2、使用 
					union u1 u;
					u.v = 1;
					u.ch[0] = 'a';
					printf("%d", u.v);	// 变成97 a的ascii吗，因为联合的修改会影响另外一部分
				联合变量所占的空间是其中最大的那个占的空间，因为他们是同一个地址
			20、枚举	// 如果你关心对应的数字可以使用宏，不关心使用枚举
				1、声明
					enum season {SPR, SUM, AUT, WIN}	// 你也可以使用 typedef 起别名。每个元素都对应一个int，也可以在其中一个赋值 SUM = 6;指定int值，这个后面的都以6递增 
				3、使用 
					enum season s = WIN;
					printf("%d", WIN);
					printf("%d", s);
		
		3、总结						  
			1、%f 和 %lf 会保留小数点后面多余的0 %g 和 %lg不会保留
			2、7默认为为long，你也可以指定7u=unsigned long，3.5默认为double，你也可以指定3.5f=float
			3、%3d // 在数字前面加3个空格，%03d在数字前面加3个0
			4、%7.2f // 表示这个浮点数要占满7个位置，不够前面使用空格补充，小数点保留2位
			5、int和long在这里是4B但是有的系统可能是8B
	13、常用的函数
		1、 int num; scanf("%d", &num);	// 到这一句程序会阻塞等待用户输入，然后赋值给num，如果是字符串可以自己使用字符串的名称就是他的地址了
		2、 sizeof()					// 用于计算变量或者数据类型占的字节数，小括号里可以写任何能当数字使用的内容，并且里面的修改不会影响实际的变量
		3、 time(0)						// <time.h> 得到系统的时间从1970-01-01 00:00:00到现在的秒数
		4、 rand()						// <stdlib.h> 得到随机数，但是默认是伪随机，你需要加入 srand(time(0))
		5、 _exit(0)					// <unistd.h> 终止程序，很少用
		6、 sleep(1) 函数				// <unistd.h> 程序休息一秒
		7、c有一个排序方法 qsort()	// <stdlib.h> 快速排出
			int comp(const void *p_v1, const void *p_v2){}	// 1=前一个大，-1=后一个大，0=相等（这是递增，如果递减就反过来）
			qsort(arr, len, sizeof(int), comp);
		8、 int i = atoi("34")		// <stdlib.h> 把字符串34 转成int 的 34
		9、 double d = atof("34")		// <stdlib.h> 把字符串34 转成double 的 34
		10、 double d = sqrt(34)		// <math.h> 34 的平方根
		11、 fprintf/fscanf				// 写的是字符数组，可以直接打开看，区别于 fwrite他写的是对应的数据类型，处理字符串，其他是直接码
			fprintf(f, "%d", 10);	// 写入文件
			fscanf(f, "%d", &d);	// 读
		12、 sprintf/sscanf
			sprintf(arr, "%d %d", 10, 10);	// 写入到一个字符数组
			sscanf(arr, "%d", &d &d);		// 读
	15、二进制(重点看) 八进制 十六进制（在计算机可以直接使用2(0-1)、8(00-8)、16(0x0-9|a-f)）
		1、 2 <-> 10
			1、非负数
				10->2 : 除2取余法
				2->10 : 从右到左 x*2^0 + x*2^1 + ... + x*2^N // 例子： 110 = 0*2^0 + 1*2^1 + 1*2^2 = 6
			2、负数
				10->2
					1.得到负数的相反数 -> 转换成二进制 -> 按位取反  -> 加1			// 为什么这么算呢我们可以想一下比如char的最大数加1 -> 1 0000 0000 但他存的时候只有后面8位0=0=正负相加=1111 1111 + 1
					例子：-14    -> 14 -> 0000 1110    -> 1111 0001 -> 1111 0010
				2->10	// 这个是表示有符号的数据最高位为1
					1.                       减1 -> 按位取反  -> 算出十进制 -> 取相反数
					例子：1111 0010 -> 1111 0001 -> 0000 1110 -> 14         -> -14
			3、总结：所以一个二进制表示的是整数还是负数，由他的数据类型(有无符号)决定，有符号的最左位是符号位，1表示负，0表示正
		2、 8 <-> 10
			1、非负数
				8->10 : 从右到左 x*8^0 + x*8^1 + ... + x*8^N  // 例子： 056 = 6*8^0 + 5*8^1 = 46
				10->2 : 除2取余法
	16、运算符
		1、普通的运算符：	+ - * / % 前++ 后++ 前-- 后-- 等等
		2、赋值运算符：		+= -= 
		3、逻辑运算符(结果为真假)
			1、&&(逻辑与)		// 两边同时为真才为真
			2、||(逻辑或)		// 两边只要有一个为真则为真
			3、三目运算符		// 例如(a ? 1 : 0) a为真时结果1，反之结果为0
		4、二进制的位预算符(有时直接使用这个速度快，他也可以使用一个位表示一个有意义的东西，节省了空间，但是这个难的话，你也可以直接使用十进制来算)
			1、&(按位与)	// 0&0->0 0&1->0 1&0->0 1&1->1 结论：两边为1才为1，其他情况为0，用于把某些位设为0
			2、|(按位或)	// 0|0->0 0|1->1 1|0->1 1&1->1 结论：两边只要有一个为1则为1，其他情况为0，用于把某些位设为1
			3、^(按异或)	// 0|0->0 0|1->1 1|0->1 1&1->0 结论：两边相反才为1,任何数与0^都是本身，任何数和1^都是本身的相反数
			4、<<(左移位) >>(右移位)
				1、<<(左移位)	// 如果是无符号位左边的丢弃，空位补0， 如果是有符号位，符号位不变，左边的丢弃，空位补0
				2、>>(右移位)	// 右边丢弃，如果是无符号数据则补0，如果是有符号数据则补符号位
			5、~(按位求反)	// 0->1 1->0
		5、运算前的数据类型转换
			1、隐式转换		// 计算之前会吧所有的类型统一，此时c会做隐式类型转换，占位小的往大的转，如果相同空间有无符号计算，会转成无符号的
			2、强制转换		// 例如 int b = (int)a 
	17、流程控制
		1、if(bool){}else if(bool){}else{}
		2、switch(1){case 1:  case 2:  default: }
		3、for(;;)	// 结合 break(跳出整个循环) 和 contine(跳出此次循环)，有一个技巧，如果正常结束那么第二个条件为false，被break的话为真(这个有待校验，最后一次break会执行3吗？)
		4、while 和 do while	// 如果至少需要执行一次请用后者
		5、goto	// 任意指定程序的执行，不推荐使用
	18、输入输出缓冲区
		1、输入缓冲区：为了避免上一次输入的错误，蔓延到下一次的接收，所以在每一次接收完需要清空使用 scanf("%*[^\n]");scanf("%*c");
		2、输出缓冲区，遇到下列四种会输出
			1、遇到 \n 
			2、函数结束
			3、输出缓冲区满了
			4、使用 fflush(stdout) 强制输出
	19、函数
		1、例如 int add(int arr[], int size) 、 void add(int arr[], int size)	
		2、被调用函数在后面，则需要在开头预声明，最好main除外其他函数都在开头预声明(因为隐式声明有可能和我们的函数对不上)，数组是地址传递，基本类型是值传递
			1、预声明语句： add(int arr[], int)
	20、文件操作
		1、文件操作的常用函数
			1、 FILE *f1 = fopen("a.txt", "r"); // 打开文件：
				第1个参数	// 文件的路径
				第2个参数	// 打开文件的模式
					1、 r		// 只读，文件不存在打开失败
					2、 r+		// 读写，文件不存在打开失败
					3、 w		// 只写，如果文件不存在则创建之，如果有会删除，再创建
					4、 w+		// 读写，如果文件不存在则创建之，如果有会删除，再创建
					5、 a		// 只写，追加，文件不存创建之
					6、 b		// 以二进制操作，和前面五个组合使用 例如 ab 和 a + b
			2、 fclose(f1); f1 = NULL;	// 关闭文件，并且置空
			3、 fread(buf, sizeof(char), 20, f1); 和 fwrite(buf, sizeof(char), size, f2);，读完之后位置指针的位置会自动移动吗？会的，可以写入 结构体
				第1个参数		// 数组，也可以写基本变量的地址&name
				第2个参数		// 数据每个元素的大小
				第3个参数		// 期望读写的元素个数
				第4个参数		// 目标文件
		2、文件的位置指针
			1、 ftell	// 获取当前位置指针的数值
			2、 rewind	// 把位置指针挪动到文件开头
			3、 fseek(p_f, 28, SEEK_SET)	// 可以把位置指针移动到文件中的任意位置
				第1个参数	// 文件指针
				第2个参数	// 第3个参数的偏移量，单位字节
				第3个参数	// 文件位置指针的位置
					SEEK_SET=1		// 文件开头
					SEEK_CUR=2		// 当前位置
					SEEK_END=3		// 文件末尾
			4、文件的大小可以使用
				fseek(p_f, 0, SEEK_END);
				int len = ftell(p_f);

			5、c中你存入文件的数据是有数据类型的
	21、变量
		全局变量：	// 作用域全局
		局部变量，	// 默认前面关键字是 auto ,作用域方法内部
		块变量		// 作用域在{}块
		静态变量	// 作用域也是函数内，或者当前文件，需要使用 static ，其他文件不能使用，不想全局变量
	22、程序在内存中是分段保存的
		1、代码段			// 保存程序中的所有的语句，在运行时不可被修改
		2、全局段			// 存放全局变量和静态变量，在程序运行中不断变化
		3、栈				// 每个一运行函数就会有属于自己的一块栈，大小有限制，不同函数不同时间运行可能占内存中同样的栈，所以有相同变量名称的你做为返回值，可能会被影响，因为这是计算机决定他的生命周期(我感觉这是c的bug)
		4、堆				// 存放动态分配的变量，必须用语句分配和销毁
			1、使用前先申请
				1、 malloc()	// <stdlib.h> 可以在堆中分配多个连续的字节并把第一个字节的地址当成返回值
					使用案例
						int *const p_v = (int*) malloc(3 * sizeof(int))	// 申请空间，返回第一个字节的地址，但不成功返回空地址
						if (p_v) {
							// 说明成功，就可以使用了，但是你使用时不要超过你申请的

							free(p_v);	// 使用完我们一定要自己释放此空间，要传首地址，而且是能释放一次
							p_v = NULL;
						}
					注意：堆中变量的首地址最好不要改动，一旦丢失则变量占用的空间无法被释放
					malloc函数返回值的地址可以做为函数的返回值使用，但是这时就不可以在函数内部释放
				2、 calloc 也可以从堆中分配变量，分配完成后每个变量赋值成0
				3、 realloc	// 可以调整堆中的空间大小
				4、 memset	// <string.h> 可以给一组变量设置数值，可以替代 calloc
					memset(arr, 0, len * sizeof(int));	// 对数组的所有元素全清零
	23、 const 关键字
		5、 const 关键字修饰的变量不可以在赋值了，但是后续可以使用指针对其操作，但是在指针钱使用const之后，这个指针就不可以操作了，但是其他指针还是可以
		6、 const int *p_a; 指针操作不了对应的普通变量，但是可以指针本身可以修改， 但是 int * const p_a;这样指针本身就不可以被修改了，但是控制不了对应的普通变量 const int * const p_a; 这样都不行了			
	
	
2、问题
	1、多个地方对文件已写的方式打开应该可以吧，但是老师说不行？难道是操作系统的差异
	2、为什么说是二进制文件，但是用文本编辑器打开不是01
	3、文件保存的都是二进制吗？

