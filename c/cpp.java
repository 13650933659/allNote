看完 孙鑫 第三讲的中间












1、c++的改变
	可以选用g++编译器，源文件扩展名可以是.cpp  .cc .C .cxx等
	不再使用c中的头文件，如果要用，可以在c头文件名前加c，#include <cxxxx>
	不再使用scanf/printf而是cin/cout，标准的C++头文件大部分不再以.h结尾

2、命名空间也称名字空间解决名称冲突
	namespace 名称 {
		//声明和定义，限定了作用域
	}
	使用指令 using namespace std;
	使用声明 using std::in;
	访问无名空间 ::name


3、 struct,union,enum
	1、 struct - C++的结构中可以有函数，称为成员函数
	2、 union  - C差不多，关键字可以省略
	3、 enum   - C++的枚举不再是普通的整数类型，而是一种独立的类型，这个体现了C++强类型的特征，关键字可以省略
	4、 bool  - c99的bool是一种宏定义，而在c++中则是专门的一种数据类型bool，bool的值一般为true(逻辑真)和false(逻辑假)，一切值非0或者NULL都视为true
	5、 C++中的运算符的别名 <%%> 就是 {}，其他字符的别名再去参考，为了解决其他国家键盘无法输入的问题

4、 函数
1、重载: 同名不同参数参数(参数类型或者个数不同)
	1、重载引入的问题 以及如何解决 
		1、跨编译器调用问题: 使用extern "C" 指定函数 按照c语言的方式来生成调用函数名

2、函数参数之哑元
	1、概念: 如果一个函数的参数 只有参数类型 没有参数名 则这个参数称之为哑元。
	2、作用: 让无参的参数列表 严格匹配
    

3、函数参数的默认值
	1、例子
		getmax(int x,int y=200);
		getmax(int x,int y,int z);
	2、注意必须是从右开始紧挨着排列



4、内联函数  inline
	1、宏函数(带参宏)
		写一个带参宏 可以完成两个整数最大值的选取 
	2、内联函数
		在编译时 请求编译器把函数的代码复制到调用位置。
		请求成功 就使用空间换取时间,请求不成功 则成为通函数调用。
	3、内联函数注意的问题
		小函数 频繁调用适合内联 
		大函数 稀少调用 不适合内联
		递归函数 无法实现内联
		
5、c++中的动态内存分配
	1、分配单个变量对应的内存
		类型 *指针名=new 类型名;
		类型 *指针名=new 类型名();      
		类型 *指针名=new 类型名(值); 
	2、释放new出来的内存
	   delete  指针名;
	   delete[]  指针名;
	3、定位内存分配 (了解) 
		char  data[100];
		int   *pdata=new (data)int[25];  // pdata 的内存指向栈中  不用考虑释放问题，并且pdata 和 data的地址是相同的
 
6、引用  
	1、概念 - 引用就是一个变量的别名，为了简化指针，但是c++的引用不太好用
	2、语法 - int& a = b; 
	3、引用的应用
		1、引用类型的参数，他是地址的传递，和指针的功能类似
		2、引用类型的返回值
	4、引用底层是如何实现的? - 引用的底层是用指针实现的。
      

7、c++ 中的类型转换运算符
	1、 static_cast<类型>(变量)       - 在某一个方向上  可以做自动类型转换的情况 ，int *  ----> void*
	2、 dynamic_cast<类型>(变量)      - 具有多态性的父子类之间
	3、 const_cast<类型>(变量)        - 专门用来去除const修饰的
	4、 reinterpret_cast<类型>(变量)  - 最接近于强制类型转换的转换,各种指针之间的转换，甚至整数变成指针  指针变成整数      

8、之父给c程序员建议
	1、尽量的少使用宏
	2、使用 enum  去替代多个常量 
	3、使用 const 替代一个常量 
	4、使用 inline 替代 带参宏 
	5、使用namespace 避免命名冲突
	6、使用泛型和模版 去刻画一组逻辑或者类型 
	7、变量随时用 随时定义 以保证初始化
	8、少用 malloc free  因为new  delete 会做的更好
	9、使用 char * 和 char数组来代表字符串，使用string 类型替代
	10、逐步建立面向对象的思想 

9、类和对象（面向对象的编程）
	1、类(class)和结构体(struct)，在C++他们是一样的东西
		1、 成员变量
		2、 成员函数
		3、 构造函数
		4、 初始化列表 Student (string& name) : m_name(name),arr:{1,2},struct_b{1993,3,16} {}
	5、 this 指针
		1、应用
			1、可以区分函数的参数和成员变量重名问题
			2、作为函数的参数 或者 参数值相关
			3、作为函数的返回值 或者返回值相关 
	6、 const 函数（修饰的是this）
		1、 const 对象 和 const函数之间的关系
			const 对象只能调用const 函数
			非const对象 优先调用非 const 函数  次之调用const函数。  
			const 函数 和 非const  可以形成重载关系 
		2、 const 函数 和 成员之间的关系
			const函数只能读成员变量的值 不能改成员变量的值，如果非要对成员变量进行修改 则 使用mutable修饰 
			const函数只能调用const函数 不能调用非const函数
	7、析构函数
		1、概念
			和类名同名   但是函数名前有一个 ~ ，没有返回值类型 没有参数，会在对象销毁之前 自动被调用一次  
			当然可以手工调用(一般不这么做)，一般是用来释放资源或者内存的
	   
		2、什么时候需要自定义析构函数
			1、堆内存释放 或者是资源释放时  
	8、 new delete 比 malloc free 多做了什么?
		1、 new 比 malloc 多做了什么 
			1、如果对象的成员是类类型 则自动构建
			2、自动调用构造函数
			3、自动处理类型转换 
		2、 delete 比 free 多做了析构函数的调用 
	9、拷贝构造函数 public A(const A &a); （这个和构造函数区分开）
		1、概念
			以复制的形式来构建对象，如果里面有指针也是复制指针，这就相当于指向同一内存。(即：浅复制)
	   
		2、拷贝构造调用时机
			1、以一个存在的对象 去创建另外一个不存在的对象的时候
			2、 把一个对象 传入一个非引用类型的值参数时 
			3、 把一个对象 做为函数的返回值时 
		3、 什么时候需要自定义拷贝 
			1、 如果不给类型提供拷贝构造 则编译器会自动提供一个默认的
			拷贝构造函数,这个函数完成的是逐字节拷贝,称之为浅拷贝。
			如果需要处理 数据的拷贝过程 或者需要处理内存独立性时需要自定义拷贝即深度拷贝。
	10、 拷贝赋值的函数 operator() // 这个有空去看一下，他涉及到 先把自己的资源释放，在重新分配
	11、静态成员
		1、静态成员函数，只能访问静态成员，不能访问普通成员  因为编译器没有传this，但普通函数可以访问静态成员
			1、访问
				1、 类名::add();	// 子类访问，父类的成员也是这样包括非静态成员
				2、 对象.name();
		2、 静态成员变量 
			1、访问
				1、 类名::name
				2、 对象.name;
		3、 恶汉式 和 懒汉式的单例模式
	12、成员指针
		1、 成员变量指针： 成员变量指针的本质，记录对象首地址的偏移量 
			1、 语法 
				1、 声明初始化
					int  C::*pm = &C::x;
				2、 使用
						C c;
						c.*pm;
						或者
						C *pc=new C();
						pc->*pm; 
		2、 成员函数指针： 成员函数的本质就是函数在代码区中的绝对地址
		 1、语法
			int (Date::*pfun)();
			pfun = &Date::getMonth;
			Date date;
			(date.*fun)();
			Date *pd=new Date;
			(pd->*fun)();
		
	13、运算符重载: 一种函数的特殊表现形式 
		1、 重写 对应的 operator# 函数即可， 
			1、比如 A& operator* 当你使用A a = new A; (*a.name)就会调用他		// 行为相当于指针，可以充当智能指针，会自动delete对内存
			2、比如 A* operator-> 当你使用A a = new A; (a->name)就会调用他
			3、比如类型转换运算符 operator int/int&/string (void) const{return m_data;}	// int&是具有左值的特性
			4、比如 void* operator new() {}		// 重写new运算符， 这样你就要自己去写 malloc delete 也一样
		2、 友元函数
			可以获得对私有成员的访问权力 
			友元函数  静态成员函数   成员函数 
				1.访问类的私有数据 
				2.受类的作用域 和 权限的控制
				3.必须通过对象调用 
		 友元只满足第一条  静态成员满足前两条 
	14、面向对象编程的三大特征: 封装、继承、多态
		1、封装： 隐藏具体的实现  然后提供公开的访问接口
		2、继承 
			1、单继承   
				1、语法
				   class  Child:public  Parent {};
				2、 c++ 中的继承方式（注意：继承方式只影响子类的子类对此基类属性的访问，直接继承基类的类，处理private之外其他都可以访问）
					1、公开继承    class Child:public Parent{ };
						public     到子类之后是公开的
						protected  到子类之后是保护的
						private    到子类之后是隐藏的
					2、保护继承    class Child:protected Parent{ };
						public     到子类之后是私有的
						protected  到子类之后是私有的
						private    到子类之后是隐藏的 
					3、私有继承    class Child:private Parent{ };
						public     到子类之后是保护的
						protected  到子类之后是保护的
						private    到子类之后是隐藏的 
				3、继承中 构造 和 析构的调用顺序
					构建子类对象 一定会先调用父类的构造函数。
					子类默认调用父类的无参构造。当然也可以指定调用父类的构造函数,需要通过初始化列表指定调用。
					析构函数的调用顺序 和 构造函数调用顺序相反。
			2、多继承
				1、概念: 一个类 可以有多个直接父类  
				2、语法: class IPhone:public Phone,public Camera,public Mp3{};
				3、多继承引入的冲突解决
					1、成员的冲突，可以使用 A.ParentA::name 具体指定是哪个父类的name
					2、虚继承解决（解决砖石继承机构时出现两份最基类）
						1.抽取共有的部分到更高层的一个类中
						2.采用虚继承 virtual 继承更高层的类，里面维护了一张虚表地址，这个以后再看
			3、多态
				1、 概念 
					通过父类型的指针(引用) 调用其虚函数,如果子类重写了这个虚函数  则调用的表现是子类的,否则就是父类型中对应的实现。
				2、 函数重写(函数覆盖  overwrite)
					1、相关的概念
						1、 函数重写: overwrite  (名字隐藏的特例)
						   当子类和父类同名的虚函数称之为函数重写，函数的返回值类 函数名 参数列表必须完全相同。好像子类的函数不需要为虚函数   
						2、名字隐藏: namehide
						   当子类提供了和父类同名的数据时 叫名字隐藏。
						3、函数重载:
						   同一个作用域中 函数名相同 参数列表不同的函数构成重载。
				3、 动态绑定 
					静态绑定:在编译器时就直接确定调用的函数地址
					动态绑定:在运行时 确定函数的调用地址
				4、 多态的底层实现
					虚函数表 ---- 虚表
					虚指针  
					   任何一个具有虚函数的类型  只有一张虚表  同类型的
						   对象共享虚函数标。  

					   当一个父类型的指针 指向一个子类对象时,调用虚函数时
						   并没有立即生成函数的调用地址。而是先根据对象定
						   位出对象前四个字节对应的虚函数表,再根据虚函数表
						   中存放的函数地址 进行调用,虚函数表中对应那个类的
						   实现就调用相应的函数。
	15、类型识别
		1、使用dynamic_cast<类型>(对象)，会尝试着把对象变成相应的类型 如果成功返回非空指针，不成功返回NULL。
		2、typeid ,这个运算符可以获得类型或者对象的类型信息。
			/usr/include/c++/4.6 下有一个头文件 #include <typeinfo>
			typeid 返回的信息存入一个type_info 类型的对象中,这个类型
			重载 ==  和 !=运算符。并且有个成员函数 name()返回类型的名称。
			如果父子类之间 没有多态性,则当父类对象指针指向子类对象时 
			   通过指针取值识别出的对象是父类型的。

	16、抽象类（如果除了构造和析构函数外的所有函数都是纯虚函数，那么此类就是纯抽象类）
		1、概念: 不能实例化的类  叫抽象类  除此之外和正常没有区别
			1、如何实现? 只要在类中出现一个纯虚函数，
				class  A{
				   public:
				   /* 这就是纯虚函数 */
				   virtual  void  show()=0;
				};
			2、如果一个类继承了抽象类 则这个类自动成为抽象类 除非实现纯虚函数。
	17、虚析构函数
		1、概念：加了 virtual 修饰的析构函数  
		2、作用
			当父类对象的指针 指向子类对象时,如果释放指针对应的内存只会调用父类对应的析构函数  子类析构行为未定义。
			如果把父类对应的析构函数修改成虚析构函数,则会调用子类
			析构函数,而子类析构函数的调用必然触发父类析构的调用。      
		3、 什么时候需要虚析构函数: 当父类型中有虚函数 或者 父子类型中都有堆内存处理时


10、异常   exception throw
	1、异常的作用 : 异常就是一种错误的表达形式 ，语言中是通过返回值代表错误调用 terminate  函数 终止进程 
	2、语法
		1、 抛异常语法 ： throw  异常;
		2、 异常的说明
			void  foo();         - 这个函数代表可能会抛出任何异常 
			void  foo()throw();  - 这个函数不抛出任何异常， 如果函数再抛出异常 抛出的异常不可捕获
			void  foo()throw(int,double); 这个函数可能抛出int 或者double异常。
			注意： 子类抛出的异常 不能比父类更多 只能比父类中更少
	3、 系统定义的异常
		1、 都是exception的子类，提供一种以类的思想来表达问题 ，我们可以使用他提供的 what 方法
11、 c++ 的io流有空再去看 第十天的视频




